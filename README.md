# КПО. Домашняя работа №4

## **Выполнил: Мищенко Александр, БПИ248-1**
## **Почта: admishchenko@edu.hse.ru**

## Описание проекта

Целью данного проекта является разработка микросервисной системы с асинхронным межсервисным взаимодействием, устойчивой к сбоям, повторной доставке сообщений и перезапускам отдельных компонентов.

Проект моделирует упрощённый интернет-магазин, в котором:
- пользователь создаёт заказ,
- система инициирует платёж,
- платёж либо подтверждается, либо отклоняется,
- итоговый статус заказа обновляется асинхронно.

Ключевой акцент сделан не на бизнес-логике, а на **архитектурных решениях**, корректном взаимодействии микросервисов и соблюдении требований надёжности доставки сообщений.

В системе намеренно отсутствуют синхронные вызовы между бизнес-сервисами (Orders ↔ Payments). Все изменения состояния передаются исключительно через события в брокере сообщений.

---

## Архитектура системы

Система состоит из следующих компонентов:

- **Gateway** — API-шлюз и единая точка входа для клиента  
- **OrdersService** — управление заказами и их жизненным циклом  
- **PaymentsService** — обработка платежей и управление балансами  
- **RabbitMQ** — брокер сообщений для асинхронного взаимодействия  

Каждый сервис:
- является независимым ASP.NET Core приложением,
- имеет собственную базу данных (SQLite),
- разворачивается в отдельном Docker-контейнере,
- масштабируем и отказоустойчив.

---

## Асинхронное взаимодействие

Взаимодействие между сервисами реализовано через RabbitMQ:

- OrdersService публикует событие `OrderCreated`
- PaymentsService подписывается на это событие и обрабатывает платёж
- PaymentsService публикует результат (`PaymentSucceeded` / `PaymentFailed`)
- OrdersService обновляет статус заказа на основе результата

RabbitMQ обеспечивает **at-least-once delivery**, а бизнес-логика сервисов гарантирует **exactly-once семантику**.

---

## Transactional Outbox / Inbox

### OrdersService — Transactional Outbox

При создании заказа:
- заказ сохраняется в таблицу `Orders`
- событие сохраняется в `OutboxMessages`
- обе операции выполняются в рамках одной транзакции

Фоновый сервис (`OutboxPublisher`) публикует события в RabbitMQ.

### PaymentsService — Inbox + Outbox

- входящие события сохраняются в `InboxMessages`
- повторно полученные события игнорируются
- результаты обработки сохраняются в `OutboxMessages`

Таким образом достигается:
- идемпотентность,
- защита от повторного списания средств,
- семантика exactly-once на уровне бизнеса.

---

## Gateway

Gateway выполняет роль API-шлюза:
- принимает HTTP-запросы от клиента,
- проксирует их в соответствующие сервисы,
- не содержит бизнес-логики и состояния.

Swagger-документация доступна через Gateway.

---

## Swagger и документация API

Swagger используется во всех сервисах:

- Gateway: http://localhost:8080/swagger
- OrdersService: http://localhost:8081/swagger
- PaymentsService: http://localhost:8082/swagger

Swagger соответствует стандарту OpenAPI 3.0.

---

## Docker и запуск системы

Все компоненты запускаются с помощью Docker Compose.

### Запуск

```bash
docker compose up --build
```

После запуска:
- Gateway доступен на `http://localhost:8080`
- RabbitMQ Management UI — `http://localhost:15672`
- логин/пароль RabbitMQ: `guest / guest`

---

## Надёжность и устойчивость

В проекте обеспечено:

- отсутствие потери сообщений,
- корректная обработка повторной доставки,
- независимость сервисов,
- устойчивость к перезапуску контейнеров,
- корректная работа при временной недоступности RabbitMQ.

---

## Итог

В рамках домашней работы реализована полноценная микросервисная система с:
- асинхронным взаимодействием,
- использованием RabbitMQ,
- паттернами Transactional Outbox и Inbox,
- семантикой exactly-once,
- контейнеризацией и документацией API.
